
# Rule: JWT Authentication Architecture Plan

## 1. Core Architecture Overview

**Two-Token System:**
- **Access Token (JWT)**: Short-lived (15-30 minutes), contains user claims, stateless
- **Refresh Token**: Long-lived (7-30 days), stored in database, used to generate new access tokens

**Token Structure:**
```json
// Access Token Payload
{
  "sub": "user_id",
  "email": "user@example.com", 
  "role": "user|admin",
  "iat": 1640995200,
  "exp": 1641001200,
  "type": "access"
}

// Refresh Token Payload  
{
  "sub": "user_id",
  "jti": "token_id", // for revocation
  "iat": 1640995200,
  "exp": 1643587200,
  "type": "refresh"
}
```

## 2. Authentication Flow

**Registration/Login Process:**
1. User submits credentials
2. Server validates credentials
3. Generate access + refresh token pair
4. Store refresh token in database (hashed)
5. Return both tokens (refresh token in httpOnly cookie, access token in response)

**API Request Flow:**
1. Client includes access token in Authorization header: `Bearer <token>`
2. Middleware validates token signature and expiration
3. Extract user info from token claims
4. Proceed with request or return 401

## 3. Refresh Token Strategy

**Token Rotation (Recommended):**
- Each refresh generates a new refresh token pair
- Old refresh token is invalidated immediately
- Prevents token replay attacks

**Refresh Flow:**
1. Client sends refresh token when access token expires
2. Server validates refresh token exists in database
3. Generate new access + refresh token pair
4. Invalidate old refresh token
5. Return new tokens

## 4. Password Reset Architecture

**Secure Reset Flow:**
1. User requests reset with email
2. Generate temporary JWT with short expiration (15-30 minutes)
3. Store reset token hash in database
4. Send email with reset link containing token
5. User clicks link, validates token, sets new password
6. Invalidate reset token after use

## 5. Temporary Login System

**Use Cases & Implementation:**
- **Email Verification**: Temporary token for account activation
- **Magic Links**: Passwordless login via email
- **Admin Impersonation**: Temporary elevated access

**Flow:**
1. Generate temporary JWT with specific claims (purpose, limited permissions)
2. Short expiration (5-15 minutes)
3. Single-use tokens stored in database
4. Convert to regular session upon validation

## 6. Database Schema

```sql
-- Users table
CREATE TABLE users (
  id UUID PRIMARY KEY,
  email VARCHAR(255) UNIQUE NOT NULL,
  password_hash VARCHAR(255) NOT NULL,
  role VARCHAR(50) DEFAULT 'user',
  email_verified BOOLEAN DEFAULT FALSE,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

-- Refresh tokens table
CREATE TABLE refresh_tokens (
  id UUID PRIMARY KEY,
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  token_hash VARCHAR(255) NOT NULL,
  expires_at TIMESTAMP NOT NULL,
  created_at TIMESTAMP DEFAULT NOW(),
  revoked_at TIMESTAMP NULL
);

-- Temporary tokens table (reset, magic links, etc.)
CREATE TABLE temp_tokens (
  id UUID PRIMARY KEY,
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  token_hash VARCHAR(255) NOT NULL,
  token_type VARCHAR(50) NOT NULL, -- 'reset', 'magic_link', 'email_verify'
  expires_at TIMESTAMP NOT NULL,
  used_at TIMESTAMP NULL,
  created_at TIMESTAMP DEFAULT NOW()
);
```

## 7. Security Best Practices

**Token Security:**
- Use strong JWT secrets (256-bit minimum)
- Implement token blacklisting for logout
- Store refresh tokens as httpOnly cookies
- Use HTTPS only for token transmission
- Implement rate limiting on auth endpoints

**Additional Security:**
- Hash refresh tokens before database storage
- Implement device tracking/fingerprinting
- Add IP address validation for sensitive operations
- Use CSRF tokens for state-changing operations
- Implement account lockout after failed attempts

## 8. Implementation Architecture

**Middleware Stack:**
```javascript
// Authentication middleware
async function authenticateToken(req, res, next) {
  const token = extractBearerToken(req.headers.authorization);
  
  try {
    const payload = jwt.verify(token, process.env.JWT_SECRET);
    req.user = payload;
    next();
  } catch (error) {
    return res.status(401).json({ error: 'Invalid token' });
  }
}

// Role-based authorization
function requireRole(role) {
  return (req, res, next) => {
    if (req.user.role !== role) {
      return res.status(403).json({ error: 'Insufficient permissions' });
    }
    next();
  };
}
```

**Key Endpoints:**
- `POST /auth/register` - User registration
- `POST /auth/login` - User login  
- `POST /auth/refresh` - Token refresh
- `POST /auth/logout` - Token revocation
- `POST /auth/forgot-password` - Password reset request
- `POST /auth/reset-password` - Password reset completion
- `POST /auth/magic-link` - Generate temporary login

## 9. Frontend Integration

**Token Storage:**
- Store access token in memory (React state/context)
- Store refresh token in httpOnly cookie (server-side)
- Implement automatic token refresh before expiration

**HTTP Interceptors:**
```javascript
// Axios interceptor example
axios.interceptors.request.use((config) => {
  const token = getAccessToken();
  if (token) {
    config.headers.Authorization = `Bearer ${token}`;
  }
  return config;
});

axios.interceptors.response.use(
  (response) => response,
  async (error) => {
    if (error.response?.status === 401) {
      const newToken = await refreshAccessToken();
      if (newToken) {
        error.config.headers.Authorization = `Bearer ${newToken}`;
        return axios.request(error.config);
      }
    }
    return Promise.reject(error);
  }
);
```

## 10. Environment Configuration

**Required Environment Variables:**
```env
JWT_SECRET=your-256-bit-secret
JWT_REFRESH_SECRET=your-refresh-secret
JWT_ACCESS_EXPIRES_IN=30m
JWT_REFRESH_EXPIRES_IN=7d
DB_CONNECTION_STRING=your-database-url
SMTP_HOST=smtp.gmail.com
SMTP_PORT=587
SMTP_USER=your-email
SMTP_PASS=your-password
FRONTEND_URL=http://localhost:3000
```

This architecture provides a robust, secure JWT authentication system with proper token management, security controls, and flexibility for various authentication scenarios.